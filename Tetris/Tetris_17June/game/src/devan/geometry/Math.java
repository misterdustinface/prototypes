package devan.geometry;

import java.util.Collection;

import com.badlogic.gdx.math.MathUtils;

/**
 * @author dustin
 */
public class Math {
	final public static double PI 		= java.lang.Math.PI;
	final public static double HALF_PI 	= PI / 2;
	final public static double TWO_PI	= PI * 2;
	
	public static float length(final LineSegment lineSegment){return distance(lineSegment.a, lineSegment.b);}
	//public static float lengthSquared(final Line lineSegment){return distanceSquared(lineSegment.a, lineSegment.b);}
	public static float distance(final Point A, final Point B){
		return sqrt(squared(A.x - B.x) + squared(A.y - B.y));
	}
	public static float distance(final float X1, final float Y1, final float X2, final float Y2){
		return sqrt(distanceSquared(X1, Y1, X2, Y2));
	}
	/**
	 * Shortest distance from the given point to the given line segment
	 * @param Point
	 * @param LineSegment Segment
	 * @return the shortest distance.
	 */
	public static float distance(final Point P, final LineSegment L){
		return Math.min(distance(P, L.a), distance(P, L.b), Math.abs(determinant(P, L))/length(L) );
	}
	
	public static float distanceSquared(final float X1, final float Y1, final float X2, final float Y2){
		return (squared(X1 - X2) + squared(Y1 - Y2));
	}
	public static float distanceSquared(final Point A, final Point B){
		return (squared(A.x - B.x) + squared(A.y - B.y));
	}
	
	public static float determinant(float a, float b, float c, float d){ return a*d - b*c; }
	
	/**
	 * A 2-Dimensional Cross-Product returning a scalar.
	 * 
	 * U and V are vectors.
	 * In 2D, UxV = det(U,V)
	 * Magnitude of the cross product is: |UxV| = |U||V|sinθ
	 * Where θ is the angle between U and V.
	 * 
	 * Reference: http://mathworld.wolfram.com/CrossProduct.html
	 * 
	 * A determinant can also determine the signed area of the parallelogram generated by its columns.
	 * 
	 * Reference: http://www.math.brown.edu/~mangahas/det.pdf
	 * 
	 * @param LineSegment Segment
	 * @param LineSegment Segment
	 * @return Scalar
	 */
	public static float determinant(LineSegment J, LineSegment Q){
		return ((J.b.x-J.a.x)*(Q.b.y-Q.a.y) - (Q.b.x-Q.a.x)*(J.b.y-J.a.y));
	}
	
	/**
	 * A 2-Dimensional Cross-Product returning a scalar.
	 * 
	 * U and V are vectors.
	 * In 2D, UxV = det(U,V)
	 * Magnitude of the cross product is: |UxV| = |U||V|sinθ
	 * Where θ is the angle between U and V.
	 * 
	 * Reference: http://mathworld.wolfram.com/CrossProduct.html
	 * 
	 * A determinant can also determine the signed area of the parallelogram generated by its columns.
	 * 
	 * Reference: http://www.math.brown.edu/~mangahas/det.pdf
	 * 
	 * @param Point
	 * @param LineSegment Segment
	 * @return Scalar
	 */
	public static float determinant(Point P, LineSegment L){
		return (L.b.x-L.a.x)*(P.y-L.a.y) - (P.x-L.a.x)*(L.b.y-L.a.y);
	}
	
	/**
	 * U and V are vectors.
	 * U*V is a dot product.
	 * U*V = cosθ
	 * 
	 * Reference: http://mathworld.wolfram.com/CrossProduct.html
	 * 
	 * @param LineSegment Segment
	 * @param LineSegment Segment
	 * @return Scalar
	 */
	public static float dotProduct(LineSegment J, LineSegment Q){
		return ((J.b.x-J.a.x)*(Q.b.y-Q.a.y) + (Q.b.x-Q.a.x)*(J.b.y-J.a.y));
	}
	/**
	 * U and V are vectors.
	 * U*V is a dot product.
	 * U*V = cosθ
	 * 
	 * Reference: http://mathworld.wolfram.com/CrossProduct.html
	 * 
	 * @param Point
	 * @param LineSegment Segment
	 * @return Scalar
	 */
	public static float dotProduct(Point P, LineSegment L){
		return (L.b.x-L.a.x)*(P.y-L.a.y) + (P.x-L.a.x)*(L.b.y-L.a.y);
	}
	
//	public static float distanceSquared(final Ray R, final Point P){
//		return (squared(R.x() - P.x) + squared(R.y() - P.y));
//	}
	
//	public static float distanceSquared(final Ray R, final Line L){
//		return distanceSquared(R, Collision.getPointOfIntersection(R,L));
//	}
	
//	public static float slope(final Line line){return slope(line.a, line.b);}
//	public static float slope(final Point A, final Point B){
//		return (A.y - B.y)/(A.x - B.x);
//	}
//	public static float getPerpendicularSlope(float slope){ return slope * -0.5f;}
	
	public static boolean isThetaLeftOfRay(Ray ray, double theta){
		return (theta < 0 && ray.getTheta() > 0) 	? theta < normalizeAngle(ray.getTheta() - PI)
													: theta > ray.getTheta();
	}
	
	public static double relativeTheta(Ray ray, Point point){ 
		//return differenceBetweenThetas(theta(ray.origin, point), ray.getTheta());
		return isThetaLeftOfRay(ray, theta(ray.origin, point)) 	? -(float)differenceMagnitudeBetweenThetas(theta(ray.origin, point), ray.getTheta()) 
																:  (float)differenceMagnitudeBetweenThetas(theta(ray.origin, point), ray.getTheta());
	}
	/**
	 * @param A
	 * @param B
	 * @return theta (θ) in radians
	 */
	public static double theta(Point A, Point B){ return MathUtils.atan2((B.y-A.y),(B.x-A.x)); }
	public static double theta(float x1, float y1, float x2, float y2){ return MathUtils.atan2((y2-y1),(x2-x1)); }
	
	/**
	 * @param theta
	 * @return perpendicular theta in radians
	 */
	public static double getPerpendicularTheta(double theta){ return normalizeAngle(theta + HALF_PI); }
	
	/**
	 * Normalizes the angle to be between -pi and pi
	 * @param theta (θ)
	 * @return normalized angle
	 */
	public static double normalizeAngle(double theta){
		if(theta >= PI){		return (theta % PI) - PI;
		}else if(theta <= -PI){	return (theta % PI) + PI;
		}else{					return  theta; }
	 }
	/**
	 * Normalizes the angle to be between 0 and TWO_PI
	 * @param theta (θ)
	 * @return normalized angle
	 */
	public static double normalizeAngleTo2Pi(double theta){ 
		if(normalizeAngle(theta) < 0){ 	return normalizeAngle(theta) + (TWO_PI); }
		else {							return theta % (TWO_PI); } 
	}
	
	public static boolean thetaIsInRange(double THETA, double LOWER_BOUND, double UPPER_BOUND, double RANGE_LENGTH){
		
		LOWER_BOUND = normalizeAngle(LOWER_BOUND);
		UPPER_BOUND = normalizeAngle(UPPER_BOUND);
		
		if(LOWER_BOUND > UPPER_BOUND){ return thetaIsInRange(THETA, UPPER_BOUND, LOWER_BOUND, RANGE_LENGTH); }
		
		THETA 		= normalizeAngle(THETA);
		
		THETA 		-= LOWER_BOUND;
		UPPER_BOUND -= LOWER_BOUND;
		// LOWER_BOUND -= LOWER_BOUND // = 0
		
		if(RANGE_LENGTH >= UPPER_BOUND){
			return UPPER_BOUND >= THETA && THETA >= 0;
		}else{
			return normalizeAngle(UPPER_BOUND) <= THETA && THETA <= 0;
		}
		//return RANGE_LENGTH >= UPPER_BOUND && UPPER_BOUND >= THETA && THETA >= 0;
	}

	
	// TODO FIXME
	// issues when rayTheta to object angle is in range -pi/2 to -pi (or is that -3/4pi?)
	// order of calling is typically theta to object, ray theta; therefore, angle of issue is from 0 to pi/2 (or I think 1/4pi) from the object point of view.
	// ----
	// test: 	ray orientation angle: 			 -3/4pi
	// 			angle to object from ray origin: -5/6pi
	/**
	 * @param thetaA
	 * @param thetaB
	 * @return The angle of space between the two given angles.
	 */
	public static double differenceBetweenThetas(double thetaA, double thetaB){
		return normalizeAngle(java.lang.Math.max(thetaA, thetaB) - java.lang.Math.min(thetaA, thetaB));
	}
	public static double differenceMagnitudeBetweenThetas(double thetaA, double thetaB){
		return java.lang.Math.abs(normalizeAngle(java.lang.Math.max(thetaA, thetaB) - java.lang.Math.min(thetaA, thetaB)));
	}
	
	/**
	 * @param A
	 * @param B
	 * @param C
	 * @return The minimum of the three given values
	 */
	public static float min(final float A, final float B, final float C){ return java.lang.Math.min(java.lang.Math.min(A,B), java.lang.Math.min(A,C)); }
	public static float sqrt(final float VALUE){ return (float) java.lang.Math.sqrt((double)VALUE);}
	public static float squared(final float VALUE){ return VALUE * VALUE; }
	public static double squared(final double VALUE){ return VALUE * VALUE; }
	public static float abs(float val){ return java.lang.Math.abs(val);}
	public static boolean isEven(final int number){ return (number & 0x1) == 0; }
	public static boolean isOdd(final int number){ return (number & 0x1) == 1; }
	public static Point midpoint(Point A, Point B){ return new Point((A.x + B.x)/2, (A.y + B.y)/2); }
	
	public static Point center(Collection<Point> points){
		Point center = new Point(0,0);
		for(Point current : points){
			center.x += current.x;
			center.y += current.y;
		}
		center.x /= points.size();
		center.y /= points.size();
		return center;
	}
	
	// FIXME
	public static Collection<Point> rotate(Collection<Point> points, double theta){
		Point center = center(points);
		
		final float COS = (float)java.lang.Math.cos(theta);
		final float SIN = (float)java.lang.Math.sin(theta);
		float xOff, yOff, length;
		for(Point current : points){
			length 	= Math.distance(center, current);
			xOff   	= length * COS;
			yOff	= length * SIN;
	
			current.x = current.x > center.x ? center.x + xOff : center.x - xOff;
			current.y = current.y > center.y ? center.y + yOff : center.y - yOff;
		}	
		return points;
	}
}
